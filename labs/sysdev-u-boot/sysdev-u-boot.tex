\subchapter{Bootloader - U-Boot}{Objectives: Set up serial
  communication, compile and install the X-Loader and U-Boot
  bootloaders, use basic U-Boot commands, set up TFTP communication
  with the development workstation.}

As the bootloader is the first piece of software executed by a
hardware platform, the installation procedure of the bootloader is
very specific to the hardware platform. There are usually two cases:

\begin{itemize}

\item The processor offers nothing to ease the installation of the
  bootloader, in which case the JTAG has to be used to initialize
  flash storage and write the bootloader code to flash. Detailed
  knowledge of the hardware is of course required to perform these
  operations.

\item The processor offers a monitor, implemented in ROM, and through
  which access to the memories is made easier.

\end{itemize}
The BeagleBone black board, which uses the TI AM335X processor, falls into
the second category. The monitor integrated in the ROM reads the eMMC
card to search for a valid bootloader before looking at the SD/MMC card slot
for a bootloader. By using the a SD/MMC card, we can
start up a OMAP3-based board without having anything installed on it.

\section{Setup}

Go to the \code{/home/<user>/labs/bootloader/} directory.

\section{MMC/SD card setup}

The ROM monitor can read files from a FAT filesystem on the eMMC
card. However, the eMMC card must be carefully partitionned, and the
filesystem carefully created in order to be recognized by the ROM
monitor. Here are special instructions to format an eMMC card
for the OMAP-based platforms.

First, connect your card reader to your workstation, with the MMC/SD
card inside. Type the \code{dmesg} command to see which device is used
by your workstation. Let's assume that this device is \code{/dev/sdb}.

\begin{verbatim}
sd 3:0:0:0: [sdb] 3842048 512-byte hardware sectors: (1.96 GB/1.83 GiB)
\end{verbatim}

\fbox{\begin{minipage}{\textwidth}
{\bfseries
Caution: read this carefully before proceeding. You could destroy
existing partitions on your PC!

Do not make the confusion between the device that is used by your
board to represent your eMMC disk (probably \code{/dev/sda}), and the device
that your workstation uses when the card reader is inserted (probably
\code{/dev/sdb}).

So, don't use the \code{/dev/sda} device to reflash your MMC disk from
your workstation. People have already destroyed their Windows
partition by making this mistake.}
\end{minipage}}

You can also run \code{cat /proc/partitions} to list all block devices
in your system. Again, make sure to distinguish the SD/MMC card from the
hard drive of your development workstation!

Type the \code{mount} command to check your currently mounted
partitions. If MMC/SD partitions are mounted, unmount them:

\begin{verbatim}
$ sudo umount /dev/sdb1
$ sudo umount /dev/sdb2
...
\end{verbatim}

Now, clear possible eMMC card contents remaining from previous training
sessions:

\begin{verbatim}
$ sudo dd if=/dev/zero of=/dev/sdb bs=1M count=256
\end{verbatim}

As we explained earlier, the TI OMAP rom monitor needs special partition geometry settings
to read partition contents. The MMC/SD card must have 255 heads and 63 sectors.

The process to create 2 valid partitions on the SD card can be done using the following script:
\begin{verbatim}
sudo ./mkcard.sh /dev/sd[x]
\end{verbatim}
Check the script to see what it does and what commands are used.


\section{U-Boot setup}

We will use U-Boot v2013.07, plus a patch to fix some issues specific for the beaglebone.

Go to the \code{/home/<user>/labs/bootloader/} directory.

\begin{verbatim}
git clone git://git.denx.de/u-boot.git
cd u-boot/
git checkout v2013.07 -b tmp
\end{verbatim}

To apply the patch on top of v2013.07, run the following commands

\begin{verbatim}
wget https://raw.github.com/eewiki/u-boot-patches/master/v2013.07/0001-am335x_evm-uEnv.txt-bootz-n-fixes.patch
patch -p1 < 0001-am335x_evm-uEnv.txt-bootz-n-fixes.patch
\end{verbatim}


Get an understanding of its configuration and compilation steps by
reading the \code{README} file, and specifically the {\em Building the
  software} section.

Basically, you need to:

\begin{itemize}

\item set the \code{CROSS_COMPILE} environment variable

\item run \code{make <NAME>_config}, where \code{<NAME>} is the name
  of a configuration file in \code{include/configs/}. For our
  platform, the configuration file is
  \code{include/configs/am335x_evm.h}. Read this file to get an idea of
  how a U-Boot configuration file is written;

\item Finally, run \code{make}\footnote{You can speed up the compiling
  by using the \code{-jX} option with \code{make}, where X is the number of parallel
  jobs used for compiling. Twice the number of CPU cores is a good
  value.}, which should build U-Boot.

\end{itemize}

You can now copy the generated \code{u-boot.img} and \code{MLO} files to the MMC card.

Unmount the MMC card partition.

\section{Setting up serial communication with the board}

\section{Beaglebone black}
To connect UART0 on the Beaglebone Black, use the supplied USB FTDI cable.
When plugged-in, the device will appear as \code{/dev/ttyUSB0}.

To communicate with the board through the serial port, install a
serial communication program, such as \code{picocom}:

You can also see this device appear by looking at the output of
\code{dmesg}.

\begin{verbatim}
sudo apt-get install picocom
\end{verbatim}

Run \code{sudo picocom -b 115200 /dev/ttyUSB0}, to start serial
communication on \code{/dev/ttyUSB0}, with a baudrate of 115200. If
you wish to exit picocom, press \code{[Ctrl][a]} followed by
\code{[Ctrl][x]}.

\section{Testing U-Boot on the MMC card}

Insert the MMC card into the BeagleBone board, reset the board and check
that it boots your new bootloaders. You can verify this by checking
the build dates:

\begin{verbatim}
U-Boot 2013.07-dirty (Oct 02 2013 - 13:13:36)

I2C:   ready
DRAM:  512 MiB
WARNING: Caches not enabled
NAND:  0 MiB
MMC:   OMAP SD/MMC: 0, OMAP SD/MMC: 1
*** Warning - readenv() failed, using default environment

musb-hdrc: ConfigData=0xde (UTMI-8, dyn FIFOs, HB-ISO Rx, HB-ISO Tx, SoftConn)
musb-hdrc: MHDRC RTL version 2.0
musb-hdrc: setup fifo_mode 4
musb-hdrc: 28/31 max ep, 16384/16384 memory
USB Peripheral mode controller at 47401000 using PIO, IRQ 0
musb-hdrc: ConfigData=0xde (UTMI-8, dyn FIFOs, HB-ISO Rx, HB-ISO Tx, SoftConn)
musb-hdrc: MHDRC RTL version 2.0
musb-hdrc: setup fifo_mode 4
musb-hdrc: 28/31 max ep, 16384/16384 memory
USB Host mode controller at 47401800 using PIO, IRQ 0
Net:   <ethaddr> not set. Validating first E-fuse MAC
cpsw, usb_ether
Hit any key to stop autoboot:  0
gpio: pin 53 (gpio 53) value is 1
mmc0 is current device
gpio: pin 54 (gpio 54) value is 1
SD/MMC found on device 0
reading uEnv.txt
** Unable to read file uEnv.txt **
gpio: pin 55 (gpio 55) value is 1
Checking if uenvcmd is set ...

uenvcmd was not defined in uEnv.txt ...
trying eMMC (BeagleBone Black) ...

mmc_send_cmd : timeout: No status update
mmc1(part 0) is current device
mmc_send_cmd : timeout: No status update
gpio: pin 54 (gpio 54) value is 1
SD/MMC found on device 1
reading uEnv.txt
** Unable to read file uEnv.txt **
gpio: pin 55 (gpio 55) value is 1
Checking if uenvcmd is set ...

uenvcmd was not defined in uEnv.txt ...
halting ...

U-Boot#
\end{verbatim}

By the message {\em Loading u-boot.img from mmc} you also get the
confirmation that your U-Boot has correctly been loaded from the MMC
device.

Interrupt the countdown to enter the U-Boot shell:
\begin{verbatim}
U-Boot #
\end{verbatim}

In U-Boot, type the \code{help} command, and explore the few commands available.

\section{Setting up Ethernet communication}

Later on, we will transfer files from the development workstation to
the board using the TFTP protocol, which works on top of an Ethernet
connection.

To start with, install and configure a TFTP server on your development
workstation, as detailed in the bootloader slides.

With a network cable, connect the Ethernet port of your board to the
one of your computer. If your computer already has a wired connection
to the network, your instructor will provide you with a USB Ethernet
adapter. A new network interface, probably \code{eth1} or \code{eth2},
should appear on your Linux system.

To configure this network interface on the workstation side, click on
the {\em Network Manager} tasklet on your desktop, and select {\em
  Edit Connections}.

\begin{center}
\includegraphics[width=8cm]{labs/sysdev-u-boot/network-config-1.png}
\end{center}

Select the new {\em wired network connection}:

\begin{center}
\includegraphics[width=8cm]{labs/sysdev-u-boot/network-config-2.png}
\end{center}

In the {\em IPv4 Settings} tab, make the interface use a static IP
address, like \code{192.168.0.1} (of course, make sure that this
address belongs to a separate network segment from the one of the main
company network).

\begin{center}
\includegraphics[width=8cm]{labs/sysdev-u-boot/network-config-3.png}
\end{center}

You can use \code{255.255.255.0} as \code{Netmask}, and leave the
\code{Gateway} field untouched (if you click on the \code{Gateway} box, you
will have to type a valid IP address, otherwise you won't be apply to
click on the \code{Apply} button).

Now, configure the network on the board in U-Boot by setting the \code{ipaddr}
and \code{serverip} environment variables:

\begin{verbatim}
setenv ipaddr 192.168.0.100
setenv serverip 192.168.0.1
\end{verbatim}

In case the board was previously configured in a different way, we
also turn off automatic booting after commands that can be used to
copy a kernel to RAM:

\begin{verbatim}
setenv autostart no
\end{verbatim}

To make these settings permanent, save the environment:

\begin{verbatim}
saveenv
\end{verbatim}

This command only works if you board has NAND memory, which the BeagleBone doesn't have.
To configure U-Boot on the BeagleBone, we need a file called \code{uEnv.txt} on he first parition of the SD-card.

Now switch your board off and on again\footnote{Power cycling your
  board is needed to make your ethaddr permanent, for obscure
  reasons. If you don't, U-boot will complain that ethaddr is not
  set.}.

You can then test the TFTP connection. First, put a small text file in
the directory exported through TFTP on your development
workstation. Then, from U-Boot, do:

\begin{verbatim}
tftp 0x80200000 textfile.txt
\end{verbatim}

This should download the file \code{textfile.txt} from your development
workstation into the board's memory at location 0x80200000 (this
location is part of the board DRAM). You can verify that the download
was successful by dumping the contents of the memory:

\begin{verbatim}
md 0x80200000
\end{verbatim}

We will see in the next labs how to use U-Boot to download and boot a kernel.

\section{Flashing the kernel in NAND flash}

\emph{NOTE: This section is for the IGEPv2 board (BeagleBone doesn't have NAND)}

In order to let the kernel boot on the board autonomously, we can
flash it in the NAND flash available on the IGEP. The NAND flash can
be manipulated in U-Boot using the \code{nand} command, which
features several subcommands. Run \code{help nand} to see the
available subcommands and their options.

After storing the X-loader, U-boot and its environment variables, we
will keep a special area in NAND flash for the Linux kernel image.
This 4th partition will be 4 MiB big, from NAND address
0x280000 to 0x680000.

So, let's start by erasing the corresponding 4 MiB of NAND flash:

\begin{verbatim}
nand erase 0x280000 0x400000
         (NAND addr) (size)
\end{verbatim}

Then, copy the kernel from TFTP into memory, using the same address as
before.

Then, flash the kernel image:

\begin{verbatim}
nand write 0x80000000 0x280000 0x400000
           (RAM addr)   (NAND addr) (size)
\end{verbatim}

Power your board off and on, to clear RAM contents. We should now be able to load
the kernel image from NAND and boot it using:

\begin{verbatim}
nand read 0x80000000  0x280000    0x400000
          (RAM addr)   (NAND addr) (size)
bootm 0x80000000
\end{verbatim}

