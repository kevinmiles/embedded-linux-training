\subchapter{Kernel - Cross-compiling}{Objective: Learn how to cross-compile a kernel for an OMAP target platform.}

After this lab, you will be able to:
\begin{itemize}
\item Set up a cross-compiling environment
\item Configure the kernel Makefile accordingly
\item Cross compile the kernel for the BeagleBone ARM board
\item Use U-Boot to download the kernel
\item Check that the kernel you compiled starts the system
\end{itemize}

\section{Setup}

Go to the \code{/home/<user>/labs/kernel} directory.
Extract \code{kernel-bbb.tar.xz} in the current folder.

\begin{verbatim}
tar -xf kernel-bbb.tar.xz
cd kernel-bbb
\end{verbatim}

Install the following packages:
\code{libqt4-dev}, \code{u-boot-tools}, \code{device-tree-compiler} and \code{lzop}.

\code{libqt4-dev} is needed for the \code{xconfig} kernel configuration interface, and \code{u-boot-tools}
is needed to build the \code{uImage} kernel image file for U-Boot.
\code{device-tree-compiler} is needed to build a device tree blob which decribes our hardware.

\section{Target system}

We are going to cross-compile and boot a Linux kernel for the BeagleBone
Black board.

\section{Cross-compiling environment setup}

To cross-compile Linux, you need to install the cross-compiling
toolchain. We will use the cross-compiling toolchain that we
previously produced, so we just need to make it available in the PATH:

\begin{verbatim}
export PATH=/usr/local/xtools/bin:$PATH
\end{verbatim}

\section{Makefile setup}

Modify the toplevel Makefile file to cross-compile for the arm
platform using the above toolchain.

\section{Linux kernel configuration}

By running \code{make help}, find the proper Makefile target to
configure the kernel for the BeagleBone board (hint: the default
configuration is not named after the board, but after the CPU
name). Once found, use this target to configure the kernel with the
ready-made configuration.

Don't hesitate to visualize the new settings by running
\code{make menuconfig} or \code{make xconfig} afterwards!

There is a config provided, the \code{beaglebone_defconfig} file in the \code{~/labs/kernel} folder.
To use the config file do the following:

\begin{verbatim}
make distclean
cp beaglebone_defconfig .config
make oldconfig
\end{verbatim}

For later use, we need to edit a bit the configuration. Change the
kernel compression from Gzip to LZMA. This compression algorithm is
far more efficient than Gzip, in terms of compression ratio, at the
expense of a higher decompression time.

\section{Cross compiling}

Before we compile the kernel, we need to copy a firmware file the correct source folder.
\begin{verbatim}
cp ../am335x-pm-firmware.bin firmware/am335x-pm-firmware.bin
\end{verbatim}

You're now ready to cross-compile your kernel. Simply run:

\begin{verbatim}
make
\end{verbatim}

and wait a while for the kernel to compile.

Look at the end of the kernel build output to see which file contains
the kernel image.

However, the default image produced by the kernel build process is not
suitable to be booted from U-Boot. A post-processing operation must be
performed using the mkimage tool provided by U-Boot developers. This
tool has already been installed in your system as part of the
\code{u-boot-tools} package. To run the post-processing operation on
the kernel image, simply run:

\begin{verbatim}
make uImage
\end{verbatim}

\section{Device Tree}
The Device Tree is a data structure for describing hardware.
After we built the kernel we need to build the Device Tree blob,
by running the following command:

\begin{verbatim}
make dtbs
\end{verbatim}

Look in the \code{arch/arm/boot/?} folder and copy the correct \code{.dtb} file to the first partition of the SD card.

\section{Setting up serial communication with the board}

Plug the BeagleBone board on your computer. Start Picocom on \code{/dev/ttyUSB0}

You should now see the U-Boot prompt:

\begin{verbatim}
U-Boot #
\end{verbatim}

To be able to boot the kernel we need to configure some U-Boot variables.
Create the file \code{uEnv.txt} on the first partition of the SD card.
Add the following lines:

\begin{verbatim}
kloadaddr=0x80800000
devtree=am335x-boneblack.dtb
dtboot=run mmcargs; fatload mmc ${mmcdev}:1 ${kloadaddr} ${bootfile} ; fatload mmc ${mmcdev}:1 ${fdtaddr} ${devtree} ; bootm ${kloadaddr} - ${fdtaddr}
uenvcmd=run dtboot
optargs=consoleblank=0
\end{verbatim}

\section{Load and boot the kernel using U-Boot}

We will use TFTP to load the kernel image to the BeagleBone board:

\begin{itemize}

\item On your workstation, make sure your \code{uImage} file is in the
  directory exposed by the TFP server.

\item On the target, load \code{uImage} from TFTP into RAM at address
  0x80200000:\\
  \code{tftp 0x80200000 uImage}

\item Boot the kernel:\\
  \code{bootm 0x80200000}

\end{itemize}

You should see Linux boot and finally hang with the following message:

\begin{verbatim}
Waiting for root device /dev/mmcblk0p2...
\end{verbatim}

This is expected: we haven't provided a working root filesystem for
our device yet.

You can automate now all this every time the board is booted or
reset. Disconnect the board and remove the SD card.

On the first partition of the SD card create the file \code{uEnv.txt}.
Here you can configure all variables, except \code{bootcmd}, the reason is that command reads in the configuration file \code{uEnv.txt}. If you want to change it you have to recompile U-Boot.

You can use commands that the \code{bootcmd} variables call and configure those in \code{uEnv.txt} to automate \code{'tftp 80200000 uImage;bootm 80200000'}

